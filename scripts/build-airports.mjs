import fs from "node:fs/promises";
import path from "node:path";

// Data sources (OurAirports → IATA codes). You can switch to a country-specific CSV if needed.
const CSV_URL = "https://davidmegginson.github.io/ourairports-data/airports.csv"; // ourairports nightly mirror
// Docs: https://ourairports.com/data/  and data dictionary: https://ourairports.com/help/data-dictionary.html

const REGION_ORDER = ["AF", "EU", "AS", "NA", "SA", "OC", "AN"]; // Antarctica last, just in case
const REGION_LABEL = {
  AF: "Africa",
  EU: "Europe",
  AS: "Asia",
  NA: "North America",
  SA: "South America",
  OC: "Oceania",
  AN: "Antarctica",
};

// Minimal CSV parser (no deps)
function parseCSV(text) {
  const rows = [];
  let i = 0, field = "", row = [], inQuotes = false;
  const pushField = () => { row.push(field); field = ""; };
  const pushRow = () => { rows.push(row); row = []; };
  while (i < text.length) {
    const c = text[i++];
    if (inQuotes) {
      if (c === '"') {
        if (text[i] === '"') { field += '"'; i++; } else { inQuotes = false; }
      } else field += c;
    } else {
      if (c === '"') inQuotes = true;
      else if (c === ",") pushField();
      else if (c === "\n") { pushField(); pushRow(); }
      else if (c === "\r") { /* ignore */ }
      else field += c;
    }
  }
  if (field.length || row.length) { pushField(); pushRow(); }
  return rows;
}

const wantedCols = ["type","name","latitude_deg","longitude_deg","continent","iso_country","municipality","iata_code"];
function indexMap(header) {
  const idx = {};
  wantedCols.forEach(c => idx[c] = header.indexOf(c));
  return idx;
}

// Some countries have multiple naming conventions; normalize a little
function niceCountry(iso, fallback) {
  const map = {
    "US": "USA",
    "GB": "UK",
    "CD": "DR Congo",
    "CG": "Congo",
    "AE": "UAE",
    "KR": "South Korea",
    "KP": "North Korea",
    "TZ": "Tanzania",
  };
  return map[iso] ?? fallback;
}

// Build label like "John F. Kennedy International Airport (JFK)"
function makeLabel(name, iata) {
  return `${name} (${iata})`;
}

// Group by region → country
function groupEntries(entries) {
  const byRegion = {};
  for (const e of entries) {
    byRegion[e.region] ??= {};
    byRegion[e.region][e.country] ??= [];
    byRegion[e.region][e.country].push(e);
  }
  // sort inside each bucket by city then label
  for (const r of Object.keys(byRegion)) {
    for (const c of Object.keys(byRegion[r])) {
      byRegion[r][c].sort((a,b) =>
        (a.city||"").localeCompare(b.city||"", "en") ||
        a.label.localeCompare(b.label, "en")
      );
    }
  }
  return byRegion;
}

const HEADER = `// Auto-generated by scripts/build-airports.mjs
// Source: OurAirports (IATA-filtered). See https://ourairports.com/data/ and https://openflights.org/data.php
// NOTE: Classified by region & country using comment blocks for readability in diffs.

export const airports = [
`;

const FOOTER = `];
`;

function blockComment(line) { return `  // ${line}\n`; }

function toRow({ value, label, city, country }) {
  // Keep your exact shape
  const c = city ? `'${city.replace(/'/g,"\\'")}'` : "''";
  const l = label.replace(/'/g,"\\'");
  return `  { value: '${value}', label: '${l}', city: ${c}, country: '${country.replace(/'/g,"\\'")}' },\n`;
}

async function main() {
  console.log("Downloading airports CSV…");
  const csv = await (await fetch(CSV_URL)).text();

  const rows = parseCSV(csv);
  const header = rows.shift();
  const idx = indexMap(header);

  const items = [];
  for (const r of rows) {
    const type = r[idx.type]; // large_airport, medium_airport, small_airport, seaplane_base, heliport, …
    const name = r[idx.name];
    const continent = r[idx.continent];      // e.g. 'AF'
    const iso = r[idx.iso_country];          // e.g. 'KE'
    const municipality = r[idx.municipality] || "";
    const iata = r[idx.iata_code];

    if (!iata || iata === "\\N") continue;   // skip non-IATA
    if (!name || !continent || !iso) continue;

    const entry = {
      region: continent,
      country: niceCountry(iso, iso),
      city: municipality,
      value: iata,
      label: makeLabel(name, iata),
      type,
    };
    items.push(entry);
  }

  // Optional: keep only airports (skip heliports/seaplane bases for cleaner autocomplete)
  const filtered = items.filter(e => /_airport$/.test(e.type) || e.type === "large_airport" || e.type === "medium_airport" || e.type === "small_airport");

  // Ensure we comfortably exceed 1,200 (dataset usually yields 5k+ with IATA)
  console.log(`Kept ${filtered.length} IATA airports.`);

  const grouped = groupEntries(filtered);

  let out = HEADER;

  for (const region of REGION_ORDER) {
    if (!grouped[region]) continue;
    out += blockComment(`=== ${REGION_LABEL[region]} ===`);
    const countries = Object.keys(grouped[region]).sort((a,b)=>a.localeCompare(b,"en"));
    for (const country of countries) {
      out += blockComment(`-- ${country} --`);
      for (const e of grouped[region][country]) {
        out += toRow(e);
      }
      out += "\n";
    }
  }

  out += FOOTER;

  const outPath = path.resolve("src/data/airports.ts");
  await fs.mkdir(path.dirname(outPath), { recursive: true });
  await fs.writeFile(outPath, out, "utf8");
  console.log(`Wrote ${outPath}`);
}

main().catch(err => { console.error(err); process.exit(1); });
